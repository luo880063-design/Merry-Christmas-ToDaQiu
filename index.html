<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merry Christmas To 小瑶</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Zhi+Mang+Xing&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            touch-action: none; /* 禁止手机默认触摸行为 */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- 文字容器 --- */
        #text-container {
            position: absolute;
            z-index: 10;
            pointer-events: none;
            /* 右对齐布局 */
            text-align: right; 
            /* 电脑端位置 */
            top: 50%;
            left: 10%; 
            transform: translateY(-50%);
            /* 开启硬件加速，防止文字在某些手机上模糊 */
            will-change: transform, opacity;
            -webkit-font-smoothing: antialiased; /* 文字抗锯齿 */
        }

        /* 通用发光动画 */
        @keyframes textGlow {
            0% { opacity: 0.9; text-shadow: 0 0 10px rgba(255, 192, 203, 0.5); }
            100% { opacity: 1; text-shadow: 0 0 20px rgba(255, 105, 180, 0.8), 0 0 40px rgba(255, 215, 0, 0.3); }
        }

        /* 第一行：Merry Christmas */
        h1 {
            font-family: 'Great Vibes', cursive;
            color: #fff;
            font-size: 5.5rem; 
            font-weight: normal;
            margin: 0;
            line-height: 1.1;
            animation: textGlow 3s ease-in-out infinite alternate;
        }
        
        /* 第二行：—To 小瑶 */
        .sub-text {
            font-family: 'Great Vibes', 'Zhi Mang Xing', cursive; 
            color: #ffb7c5; 
            font-size: 2.8rem; 
            margin-top: 5px;
            font-weight: normal;
            animation: textGlow 3s ease-in-out infinite alternate-reverse;
        }

        /* --- 手机端适配 --- */
        @media (max-width: 768px) {
            #text-container {
                top: 15%;
                left: auto;
                right: 5%; 
                transform: none;
                width: 90%;
            }
            h1 { font-size: 3.5rem; }
            .sub-text { font-size: 2.0rem; } 
        }
    </style>
</head>
<body>

    <div id="text-container">
        <h1>Merry Christmas</h1>
        <div class="sub-text">—To 小瑶</div>
    </div>
    <canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // 优化性能

    let w, h; 
    let particles = [];
    let snowParticles = [];
    let treeCenterX, treeCenterY;

    // --- 配置参数 ---
    const config = {
        // 稍微调深一点颜色，增加质感
        treeColor: 'hsla(335, 90%, 65%, 0.8)', 
        trunkColor: 'hsla(335, 80%, 35%, 1)',   
        sparkleColor: 'hsla(320, 100%, 95%, 1)', 
        lightColor: 'hsla(45, 100%, 60%, 1)',    
        
        snowColor: 'rgba(255, 255, 255, 0.95)',
        // 粒子数量适中，太多会掉帧，太少不清晰
        leafCount: 1600,  
        trunkCount: 120,
        snowCount: 150
    };

    // --- 核心：超清屏适配函数 ---
    function resize() {
        // 强制获取设备像素比，至少为2 (保证高清)
        const dpr = Math.max(window.devicePixelRatio || 1, 2);
        
        w = window.innerWidth;
        h = window.innerHeight;

        // 设置 Canvas 的物理像素大小 (真实像素)
        canvas.width = w * dpr;
        canvas.height = h * dpr;

        // 设置 Canvas 的 CSS 显示大小 (逻辑像素)
        canvas.style.width = w + "px";
        canvas.style.height = h + "px";

        // 重置坐标系并缩放，确保后续绘图逻辑无需修改
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
        ctx.scale(dpr, dpr);

        // 重新计算树的位置
        if (w > h) {
            treeCenterX = w * 0.75;
            treeCenterY = h * 0.5 + 40; 
        } else {
            treeCenterX = w * 0.5;
            treeCenterY = h * 0.65; 
        }
    }
    
    // 监听 resize，并防抖动
    window.addEventListener('resize', resize);
    resize();

    const fov = 350;
    const viewDist = 550; 
    let angleY = 0;

    // --- 粒子系统 ---
    class Particle {
        constructor(type) {
            this.type = type;
            this.reset();
        }

        reset() {
            if (this.type === 'trunk') {
                const trunkHeight = 100;
                const trunkWidth = 30; 
                this.y = 350 + Math.random() * trunkHeight; 
                
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * trunkWidth;
                
                this.x = Math.cos(angle) * r;
                this.z = Math.sin(angle) * r;
                
                this.color = config.trunkColor;
                this.size = Math.random() * 2 + 2;
                this.blinkSpeed = 0;
                this.alpha = 1;
                
            } else if (this.type === 'leaf') {
                const treeHeight = 750;
                this.y = (Math.random() * treeHeight) - 400; 
                
                const normY = (this.y + 400) / treeHeight;
                const maxRadius = 320 * normY; 
                const r = Math.random() * maxRadius;
                const angle = Math.random() * Math.PI * 2;

                this.x = Math.cos(angle) * r;
                this.z = Math.sin(angle) * r;

                const randomVal = Math.random();
                if (randomVal > 0.94) {
                    this.color = config.lightColor; // 黄灯
                    this.size = Math.random() * 3 + 4; // 灯大一点
                    this.blinkSpeed = 0.02 + Math.random() * 0.03;
                    this.isLight = true;
                } else if (randomVal > 0.88) {
                    this.color = config.sparkleColor; // 高光
                    this.size = Math.random() * 2 + 1;
                    this.blinkSpeed = 0.04 + Math.random() * 0.08;
                    this.isLight = true; // 高光也算灯
                } else {
                    this.color = config.treeColor; // 普通叶子
                    this.size = Math.random() * 2 + 2; // 叶子稍微大一点点，填补空隙
                    this.blinkSpeed = 0.01;
                    this.isLight = false;
                }
                this.alpha = 0.6 + Math.random() * 0.4; // 增加基础透明度，更实
            }
        }

        update() {
            if (this.blinkSpeed > 0 && this.type === 'leaf') {
                this.alpha += this.blinkSpeed;
                if (this.isLight) {
                    if (this.alpha > 1 || this.alpha < 0.6) this.blinkSpeed *= -1;
                } else {
                    if (this.alpha > 1 || this.alpha < 0.4) this.blinkSpeed *= -1;
                }
            }
        }

        draw() {
            const cos = Math.cos(angleY);
            const sin = Math.sin(angleY);
            const rx = this.x * cos - this.z * sin;
            const rz = this.z * cos + this.x * sin;

            const scale = fov / (fov + rz + viewDist);
            const x2d = rx * scale + treeCenterX;
            const y2d = this.y * scale + treeCenterY;

            if (scale > 0) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(x2d, y2d, this.size * scale, 0, Math.PI * 2);
                ctx.fill();
                
                // 【清晰度优化关键】
                // 只有灯光（isLight）才绘制发光晕
                // 普通树叶不加光晕，保持边缘锐利，避免画面糊成一团
                if (this.isLight) {
                    ctx.shadowBlur = 10 * scale; // 光晕范围
                    ctx.shadowColor = this.color;
                    ctx.fill(); // 再填一次加深光晕
                    ctx.shadowBlur = 0; // 立即重置，防止影响下一个粒子
                }
                
                ctx.globalAlpha = 1;
            }
        }
    }

    class Snow {
        constructor() {
            this.reset(true);
        }
        reset(initial = false) {
            this.x = Math.random() * w;
            this.y = initial ? Math.random() * h : -10;
            this.z = (Math.random() - 0.5) * 800;
            this.vy = 0.8 + Math.random() * 1.5; 
            this.size = Math.random() * 3 + 1; // 雪花也稍微大一点，更清楚
        }
        update() {
            this.y += this.vy;
            if (this.y > h) this.reset();
        }
        draw() {
            ctx.fillStyle = config.snowColor;
            const scale = 1 + (this.z / 1000); 
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    function init() {
        particles = [];
        snowParticles = [];

        for (let i = 0; i < config.leafCount; i++) particles.push(new Particle('leaf'));
        for (let i = 0; i < config.trunkCount; i++) particles.push(new Particle('trunk'));
        
        // 树顶星星
        for (let i=0; i<40; i++) {
            let p = new Particle('leaf'); 
            p.y = -410; 
            p.x = (Math.random()-0.5)*12;
            p.z = (Math.random()-0.5)*12;
            p.color = '#fff';
            p.size = 3; 
            p.isLight = true;
            particles.push(p);
        }

        for (let i = 0; i < config.snowCount; i++) snowParticles.push(new Snow());
    }

    function animate() {
        ctx.clearRect(0, 0, w, h);
        
        // 【重要】取消全局 lighter 混合模式
        // 改为默认模式 (source-over)，这样颜色更实、更准、边缘更清晰
        // 只有在画灯光的时候，通过 shadowBlur 模拟发光
        
        particles.sort((a, b) => {
            const az = a.z * Math.cos(angleY) + a.x * Math.sin(angleY);
            const bz = b.z * Math.cos(angleY) + b.x * Math.sin(angleY);
            return bz - az;
        });

        particles.forEach(p => {
            p.update();
            p.draw();
        });

        snowParticles.forEach(p => {
            p.update();
            p.draw();
        });

        angleY -= 0.003; 
        requestAnimationFrame(animate);
    }

    init();
    animate();

</script>
</body>
</html>


